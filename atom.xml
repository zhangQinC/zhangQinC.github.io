<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhang&#39;s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="https://zhangqinc.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangqinc.github.io/"/>
  <updated>2022-07-25T09:32:28.016Z</updated>
  <id>https://zhangqinc.github.io/</id>
  
  <author>
    <name>Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象的三大特征</title>
    <link href="https://zhangqinc.github.io/2022/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/"/>
    <id>https://zhangqinc.github.io/2022/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/</id>
    <published>2022-07-25T09:30:25.000Z</published>
    <updated>2022-07-25T09:32:28.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h1><p>面向对象有三个大特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><blockquote><p>面向对象的三大基本特征都是为了代码重用</p><p>即减少重复性的代码，大大降低程序员的工作量，提高代码的复用率。</p></blockquote><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装就是把客观事物封装成（定义成）抽象的类，且隐藏类的属性（对其私有化，使用<code>private</code>修饰符修饰）和实现细节，只对外公开一些接口来实现对指定数据的修改（set）和读取（get）,以及指定功能（方法method）的使用。</p><p>将属性封装起来再提供接口来访问和设置相比提供一个简单的公共数据字段复杂，但是却明显有以下好处：</p><ol><li><p>可以改变内部实现，而除了该类的方法以外，不回应i想其他方法。</p></li><li><p>setter方法可以完成错误检查，即检查传进的参数是否有问题，不符合预期。</p></li><li><p>增强了安全性并简化了编程，</p><blockquote><p>比如我们可以对一个指定属性只设置Getter方法而不设置Setter方法，这样的话，一旦在构造器中设置此字段，就没有任何方法可以对它进行修改</p></blockquote></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的基本思想是:</p><p>基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。</p><blockquote><p>父类抽取出了他所有子类的共性，而每个子类都有都继承了父类的特征（属性和方法），又可以增加属于自己的特征（属性和方法）。</p></blockquote><h3 id="is-a关系"><a href="#is-a关系" class="headerlink" title="is-a关系"></a><code>is-a</code>关系</h3><p><code>is-a</code>关系是继承的一个明显特征。</p><blockquote><p>假如你在某个公司工作，这个公司里的经理和普通员工的待遇存在一些差异，但是也有着很多相同的地方，比如说他们都领工资，但是经理在领完工资后还有奖金，这时就需要继承。</p><p>我们需要为经理定义一个Manager类，继承Employee类，并增加一些新的功能</p></blockquote><p>上述例子中<code>Manager</code>和<code>Employee</code>之间存在着<code>is-a</code>关系。</p><p>Java中，使用<code>extends</code>关键字来表示继承，如下形式来定义继承<code>Employee</code>类的<code>Manager</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    added methods and fields.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键字extends"><a href="#关键字extends" class="headerlink" title="关键字extends"></a>关键字extends</h3><p>关键字extends表明正在构造的新类派生于一个已存在的类。</p><p>这个已存在的类称为超类（superclass）、基类（base class）、或者父类（parent class）</p><p>新类称为子类（subclass）、派生类（derived class）或者孩子类（child class）。</p><blockquote><p>尽管Employee类是一个父类，但是他并不比子类拥有更多的功能，相反，子类比父类拥有的功能更多。</p></blockquote><p>通过扩展父类定义子类的时候，只需要指出子类与父类的<strong>不同之处</strong>即可，所以在设计类的时候，应该将最一般的方法放在父类中，而将更特殊的方法放在子类中。</p><p>即，<strong>需要将通用功能抽取到父类</strong></p><h3 id="覆盖方法（Override）"><a href="#覆盖方法（Override）" class="headerlink" title="覆盖方法（Override）"></a>覆盖方法（Override）</h3><p>父类中的有些方法对子类不一定使用，为此需要提供一个新的方法来覆盖&#x2F;重写（Override）父类中的这个方法。</p><p>只需要定义一个与父类中需要重写的方法同名的方法并加上注解<code>@Override</code>即可重写该方法。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><h3 id="阻断继承：final类和方法"><a href="#阻断继承：final类和方法" class="headerlink" title="阻断继承：final类和方法"></a>阻断继承：final类和方法</h3><p><strong>不允许扩展的类</strong>被称为final类。即该类不能作为父类，不允许被继承，或者说不能派生子类。</p><p>在定义类时用<code>final</code>修饰符就表明这个类是<code>final</code>类。</p><p>类中的某个方法也可以被声明为<code>final</code>，这样的话，子类就不能重写该方法。（final类中的所有方法默认为final方法，当然，final类不拥有子类）</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><code>is-a</code>规则指出子类的每个对象也是父类的对象。例如，每个经理都是员工，反之则不然，并不是每一名员工都是经理。</p><p><code>is-a</code>规则的另一种表述是替换原则。他指出程序中出现父类的任何地方都可以使用子类对象替换。</p><p><strong>可以将子类对象赋给父类变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line"> <span class="comment">// </span></span><br></pre></td></tr></table></figure><p>在Java中，对象变量是多态的（polymorphic）。</p><p>一个<code>Employee</code>类型的变量，既可以引用一个<code>Employee</code>类型的对象，<strong>也可以引用<code>Employee</code>类的任何一个子类的对象。</strong></p><p>但是不能将父类引用赋给子类变量。</p><blockquote><p>当一个父类变量存放了一个子类引用时，此变量只能够使用父类的方法，而不能使用子类的方法，因为其声明的类型是父类。即不能调用子类新增的扩展的方法和属性。</p><p>但是此时若是子类中相应的重写了父类的方法，则调用的是子类中已经重写的方法。</p></blockquote><h3 id="多态的优点："><a href="#多态的优点：" class="headerlink" title="多态的优点："></a>多态的优点：</h3><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><h3 id="多态存在的三个必要条件："><a href="#多态存在的三个必要条件：" class="headerlink" title="多态存在的三个必要条件："></a>多态存在的三个必要条件：</h3><ul><li>继承</li><li>重写（子类继承父类后对父类方法进行重新定义）</li><li>父类引用指向子类对象</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象的三大特征&quot;&gt;&lt;a href=&quot;#面向对象的三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象的三大特征&quot;&gt;&lt;/a&gt;面向对象的三大特征&lt;/h1&gt;&lt;p&gt;面向对象有三个大特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;继承&lt;/l</summary>
      
    
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/categories/Java-SE/"/>
    
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="https://zhangqinc.github.io/2022/07/25/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://zhangqinc.github.io/2022/07/25/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2022-07-25T09:30:02.000Z</published>
    <updated>2022-07-25T09:31:44.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interface-and-abstract-class"><a href="#Interface-and-abstract-class" class="headerlink" title="Interface and abstract class"></a><code>Interface</code> and <code>abstract class</code></h2><h2 id="为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？"><a href="#为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？" class="headerlink" title="为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？"></a>为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？</h2><p>使用抽象类表示通用属性存在一个很严重的问题：</p><p>每个类只能扩展一个类。</p><p>Java是不支持多重继承的，但是<strong>每个类可以实现多个接口。</strong></p><blockquote><p>有些编程语言中允许一个类有多个父类（C++），我们将这个特性称为多重继承。</p><p>Java不支持多重继承，主要原因是多重继承会让语言变的非常复杂（如同C++），或者效率会降低（如同Eiffel）。</p></blockquote><p><strong>实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Interface-and-abstract-class&quot;&gt;&lt;a href=&quot;#Interface-and-abstract-class&quot; class=&quot;headerlink&quot; title=&quot;Interface and abstract class&quot;&gt;&lt;/a&gt;&lt;c</summary>
      
    
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/categories/Java-SE/"/>
    
    
    <category term="面试题" scheme="https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>autoboxing</title>
    <link href="https://zhangqinc.github.io/2022/07/24/autoboxing/"/>
    <id>https://zhangqinc.github.io/2022/07/24/autoboxing/</id>
    <published>2022-07-24T11:38:27.000Z</published>
    <updated>2022-07-24T11:39:21.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h1><blockquote><p>Java是一门非常纯粹的面向对象的编程语言,其设计理念是“一切皆对象”。<strong>但8种基本数据类型却不具备对象的特性。</strong>据说Java之所以提供8种基本数据类型,主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性,但在某些时候也会受到一些制约。比如,所有的引用类型的变量都继承于Object类,都可以当做Object类型的变量使用,但基本数据类型却不可以。<strong>如果某个方法需要Object类型的参数</strong>,但实际需要传入的值却是数字的话,就需要做特殊的处理了。</p></blockquote><p>这时我们需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。</p><p>eg： <code>Integer</code> 类对应基本类型为<code>int</code>。通常，这些与基本类型对应的类称为包装器（wrapper）。</p><p><strong>包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</strong></p><p>同时，包装器类还是<code>final</code>，因此不能派生它们的子类。</p><blockquote><p>假设我们想要定义一个整型数组列表。但是尖括号中的类型参数不允许是基本类型，<code>ArrayList&lt;int&gt;</code>是不允许的。这时我们就可以用到Integer包装器类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></blockquote><p>这样，我们在向list中添加数据时，就应该添加<code>Integer</code>对象，但是，Java中有一个很有用的特性，<strong>可以很简单的向<code>ArrayList&lt;Integer&gt;</code>中添加int类型的元素</strong>；</p><p>让</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>自动的变换成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(Integer.valueOf(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>这种变换称为<strong>自动装箱(autoboxing)</strong></p><blockquote><p>“装箱”（boxing）这个词来源于C#</p></blockquote><p>相反的，当将一个<code>Integer</code>对象赋给一个int值时，将会<strong>自动的拆箱。</strong></p><p>也就是说，<strong>编译器</strong>将以下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i)</span><br></pre></td></tr></table></figure><p>转换成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.get(i).intValue();</span><br></pre></td></tr></table></figure><h2 id="自动的装箱与拆箱也适用于算术表达式。"><a href="#自动的装箱与拆箱也适用于算术表达式。" class="headerlink" title="自动的装箱与拆箱也适用于算术表达式。"></a>自动的装箱与拆箱也适用于算术表达式。</h2><p>例如自增运算符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = 3;</span><br><span class="line">n++; // 编译器自动插入一条对象拆箱的指令，运算完成后再装箱。</span><br></pre></td></tr></table></figure><p>大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性。</p><p>​&#x3D;&#x3D; 运算符运用于对象时检测的是对象是否有相同的内存位置。</p><ul><li>不同包装类不能直接进行比较不能用&#x3D;&#x3D;进行直接比较。</li><li>不能使用<code>compareTo</code>方法进行比较,虽然它们都有<code>compareTo</code>方法,但该方法只能对相同类型进行比较</li></ul><p>所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span>(a == b)...</span><br><span class="line">    <span class="comment">//此语句通常会失败；</span></span><br></pre></td></tr></table></figure><h2 id="自动装箱规范要求"><a href="#自动装箱规范要求" class="headerlink" title="自动装箱规范要求"></a>自动装箱规范要求</h2><blockquote><p><code>boolean、byte、char &lt;= 127</code></p><p>介于-128和127之间的short和int被包装到固定的对象中。</p><p>即如果在此范围内的short&#x2F;int值的&#x3D;&#x3D;运算比较结果一定成功。</p></blockquote><h2 id="自动装箱注意的点："><a href="#自动装箱注意的点：" class="headerlink" title="自动装箱注意的点："></a>自动装箱注意的点：</h2><ol><li><p>包装器类引用可以为<code>null</code>，若没有值，则可能会<code>NullPointerException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span>*n); <span class="comment">// throws NullPointerException</span></span><br></pre></td></tr></table></figure></li><li><p>若在一个条件表达式中混合使用<code>Integer</code>和<code>Double</code>类型，<code>Integer</code>值就会拆箱，提升转换为<code>double</code>，再装箱为<code>Double</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="literal">true</span>? n : x);</span><br><span class="line"><span class="comment">// prints 1.0</span></span><br></pre></td></tr></table></figure></li><li><p>装箱和拆箱是编译器要做的工作，而不是虚拟机。</p><p>编译器在生成类的字节码文件时就会插入必要的方法调用（自动的拆箱和装箱），虚拟机只是执行这些代码。</p></li></ol><hr><p>使用数值包装器通常还有一个原因：<strong>可以将某些基本方法放在包装器中，会很方便</strong>—&gt; API文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个数字字符串转换成数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line"><span class="comment">// 这里，parseInt与Integer对象没关系，它是一个static静态方法(工具方法)，只是Integer类是一个放它的好地方。</span></span><br></pre></td></tr></table></figure><p>其它数值类也实现了一些有用的方法。</p><hr><blockquote><p>Warning:</p><p>有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。</p><p>Java方法的参数总是按值传递，所以不可能编写一个能够增加整型参数值的Java方法。</p><p>因为Integer对象是<strong>不可变的</strong>，包含在包装器中的内容不会改变。不能使用这些包装器类创建会修改数值参数的方法。</p><blockquote><p>如果确实向别写一个修改数值参数值的方法，可以使用<code>org.omg.CORBA</code>包中定义的某个持有者（holder）类型，包括<code>IntHolder</code>、<code>BooleanHolder</code>等。</p></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象包装器与自动装箱&quot;&gt;&lt;a href=&quot;#对象包装器与自动装箱&quot; class=&quot;headerlink&quot; title=&quot;对象包装器与自动装箱&quot;&gt;&lt;/a&gt;对象包装器与自动装箱&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java是一门非常纯粹的面向对象的编程语言,其设计</summary>
      
    
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/categories/Java-SE/"/>
    
    
    <category term="面试题" scheme="https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java中常用Class</title>
    <link href="https://zhangqinc.github.io/2022/07/24/Class/"/>
    <id>https://zhangqinc.github.io/2022/07/24/Class/</id>
    <published>2022-07-24T10:44:13.000Z</published>
    <updated>2022-07-24T10:46:52.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中部分常用内置类"><a href="#Java中部分常用内置类" class="headerlink" title="Java中部分常用内置类"></a>Java中部分常用内置类</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Java中字符串属于对象，Java内置的String类来创建和操作字符串。</p><p>拼接字符串最常用的是+，而很少用String的concat方法。</p><h3 id="int-compareTo-String-anotherString"><a href="#int-compareTo-String-anotherString" class="headerlink" title="int compareTo(String  anotherString)"></a>int compareTo(String  anotherString)</h3><p>按照字符串顺序，比较两个字符串的不同。</p><h3 id="boolean-contains-CharSequence-cs"><a href="#boolean-contains-CharSequence-cs" class="headerlink" title="boolean contains(CharSequence cs)"></a>boolean contains(CharSequence cs)</h3><p>当字符串包含指定的char值序列时返回true。</p><h3 id="boolean-equals-Object-anObject"><a href="#boolean-equals-Object-anObject" class="headerlink" title="boolean equals(Object anObject)"></a>boolean equals(Object anObject)</h3><p>与指定对象比较，与String对象比较时比较字符串内容是否相同。</p><h3 id="int-indexOf-int-ch"><a href="#int-indexOf-int-ch" class="headerlink" title="int indexOf(int ch)"></a>int indexOf(int ch)</h3><p>返回字符串第一次出现指定字符的序列。</p><h3 id="int-lastIndexOf-int-ch"><a href="#int-lastIndexOf-int-ch" class="headerlink" title="int lastIndexOf(int ch)"></a>int lastIndexOf(int ch)</h3><p>从后往前遍历返回字符串第一次出现指定字符的序列。</p><h3 id="int-length"><a href="#int-length" class="headerlink" title="int length()"></a>int length()</h3><p>返回该字符串的长度。</p><h3 id="char-toCharArray"><a href="#char-toCharArray" class="headerlink" title="char[] toCharArray()"></a>char[] toCharArray()</h3><p>将此字符串转换为一个char类型的数组返回。</p><hr><p>更多详细内容请见：<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#">https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#</a></p><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>此类用于生成随机数。</p><h3 id="int-nextInt"><a href="#int-nextInt" class="headerlink" title="int nextInt()"></a>int nextInt()</h3><p>返回一个int型的伪随机数。</p><h3 id="int-nextInt-int-bound"><a href="#int-nextInt-int-bound" class="headerlink" title="int nextInt(int bound)"></a>int nextInt(int bound)</h3><p>返回一个0到指定范围（不包括）内的随机int值。</p><h3 id="float-nextFloat"><a href="#float-nextFloat" class="headerlink" title="float nextFloat()"></a>float nextFloat()</h3><h3 id="double-nextDouble"><a href="#double-nextDouble" class="headerlink" title="double nextDouble()"></a>double nextDouble()</h3><h3 id="long-nextLong"><a href="#long-nextLong" class="headerlink" title="long nextLong()"></a>long nextLong()</h3><hr><p>更多详情请见：<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Random.html">https://docs.oracle.com/javase/9/docs/api/java/util/Random.html</a></p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math 类包含执行基本数值运算的方法，例如初等指数、对数、平方根和三角函数。</p><p>Math类中的方法都为 static ，所以可直接调用，而不用创建对象。</p><h3 id="static-int-abs-int-a"><a href="#static-int-abs-int-a" class="headerlink" title="static int abs(int a)"></a>static int abs(int a)</h3><p>返回int类型值的绝对值</p><h3 id="static-double-abs-int-a"><a href="#static-double-abs-int-a" class="headerlink" title="static double abs(int a)"></a>static double abs(int a)</h3><p>…</p><h3 id="static-int-max-int-a-int-b"><a href="#static-int-max-int-a-int-b" class="headerlink" title="static int max(int a, int b)"></a>static int max(int a, int b)</h3><p>返回两个int值中更大的一个</p><p>…</p><h3 id="static-int-min-int-a-int-b"><a href="#static-int-min-int-a-int-b" class="headerlink" title="static int min(int a, int b)"></a>static int min(int a, int b)</h3><p>返回两个int值中更大的一个</p><p>…</p><h3 id="static-double-pow-double-a-double-b"><a href="#static-double-pow-double-a-double-b" class="headerlink" title="static double pow(double a, double b)"></a>static double pow(double a, double b)</h3><p>返回第一个参数的第二个参数次幂的值。</p><p>…</p><hr><p>更多详细方法详见：<a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html">https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html</a></p><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><p>Scanner是一个简单的文本扫描器。</p><p>简单的使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br></pre></td></tr></table></figure><h3 id="int-nextInt-1"><a href="#int-nextInt-1" class="headerlink" title="int nextInt()"></a>int nextInt()</h3><p>将输入的下一个标记扫描为 int。</p><hr><p>更多细节方法内容见:<a href="https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html">https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java中部分常用内置类&quot;&gt;&lt;a href=&quot;#Java中部分常用内置类&quot; class=&quot;headerlink&quot; title=&quot;Java中部分常用内置类&quot;&gt;&lt;/a&gt;Java中部分常用内置类&lt;/h1&gt;&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot;</summary>
      
    
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/categories/Java-SE/"/>
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>Array</title>
    <link href="https://zhangqinc.github.io/2022/07/23/Array/"/>
    <id>https://zhangqinc.github.io/2022/07/23/Array/</id>
    <published>2022-07-23T07:49:06.000Z</published>
    <updated>2022-07-24T10:47:22.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>​数组存储相同类型值的序列。</p><p>​数组是一种数据结构，用来存储同一类型值的集合。</p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>通过一个整型下标（index）或者称为索引，可以访问数组中的每一个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如： 如果 a 是一个整型数组（int[]）,</span><br><span class="line">  a[i] 即为数组中下标为i的整数。</span><br></pre></td></tr></table></figure><p>声明数组时需要指出数组类型(数据元素类型后紧跟 [] )以及数组名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] a;</span><br></pre></td></tr></table></figure><p>上述语句只声明了一个变量a，并没有将它真正初始化为一个数组，应该用new操作符创建数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 此语句声明并初始化了一个可以存储100个int型数据元素的数组。</span></span><br><span class="line"><span class="comment">//即声明格式为:</span></span><br><span class="line"><span class="comment">//数据类型[] 变量名 = new 数据类型[数组长度]</span></span><br></pre></td></tr></table></figure><blockquote><p>定义一个数组变量有两种方法：</p><p>int[] a;</p><p>int a[];</p><p>这里建议用第一种，因为它更加清晰更容易理解，它将变量名和数据类型分开</p></blockquote><ul><li>数组长度不要求是常量，即也可为变量。</li><li>一旦创建了数组，它的长度就固定了，不能再做改变，</li><li>数组元素的值可以任意改变</li></ul><blockquote><p>程序运行中需要经常扩展数组的大小，这时我们可以声明一个新的更大的数组，再将需要扩展的数组的元素拷贝到新的数组。</p><p>但是当需要扩展数组大小时我们应该使用另一种数据结构——数组列表（array list）</p></blockquote><p>Java中，提供了叶子红创建数组对象并为其提供初始值的简写形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 此语法不需要new，甚至不需要指定数组长度。</span></span><br><span class="line"><span class="comment">// 最后一个值后面允许有逗号。</span></span><br></pre></td></tr></table></figure><p>注：数组允许重新初始化。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p><code>int[] a = new int[100]</code></p><p>此数组的下标是 0-99，而不是 1-100。</p><p><strong>创建一个数组时：</strong></p><ul><li>所有元素都会被初始化为0</li><li>boolean 数组的元素会被初始化为 false</li><li>对象数组的元素会被初始化为null，表示这些元素还未存放任何对象。</li></ul><blockquote><p>注：如果试图访问数组范围以外的数据<code>eg: a[100]</code>,即越界，就会引发“array index out of bounds”异常。</p></blockquote><p>要获取数组长度可以使用<code>array.length</code>。</p><h2 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for each 循环"></a>for each 循环</h2><p><code>for each</code>是Java中一种功能很强的循环结构，额可以用来依次处理数组或者其他元素集合中的每一个值，而<strong>不用去考虑下标值</strong>。</p><p>增强for循环的语句格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement</span><br></pre></td></tr></table></figure><p>for each 循环语句会遍历数组中的每一个元素</p><blockquote><p>当然，使用传统的for循环也能实现相同的效果</p><p>但是for each的代码更加简洁，不易出错， 你可以不必担心下标的起始问题。</p><p>当然，for each只适用于遍历数组的所有元素的情况。<strong>很多情况下仍要使用传统的for循环。</strong></p></blockquote><blockquote><p>利用Arrays类中的<code>toString</code>方法可以更加简单快速的打印数组中的所有元素。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;​	数组存储相同类型值的序列。&lt;/p&gt;
&lt;p&gt;​	数组是一种数据结构，用来存储同一类型值的集合。&lt;/p&gt;
&lt;h2 id=&quot;声明数组&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/categories/Java-SE/"/>
    
    
    <category term="Java SE" scheme="https://zhangqinc.github.io/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://zhangqinc.github.io/2022/07/23/hello-world/"/>
    <id>https://zhangqinc.github.io/2022/07/23/hello-world/</id>
    <published>2022-07-23T05:24:15.056Z</published>
    <updated>2022-07-23T05:24:15.056Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
