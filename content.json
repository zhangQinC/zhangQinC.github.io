{"meta":{"title":"zhang's blog","subtitle":"blog","description":"My Blog","author":"Zhang","url":"https://zhangqinc.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-07-24T02:01:52.130Z","updated":"2022-07-24T02:01:52.130Z","comments":false,"path":"/404.html","permalink":"https://zhangqinc.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"about/index.html","permalink":"https://zhangqinc.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"books/index.html","permalink":"https://zhangqinc.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"categories/index.html","permalink":"https://zhangqinc.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":true,"path":"links/index.html","permalink":"https://zhangqinc.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"repository/index.html","permalink":"https://zhangqinc.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-24T02:01:52.133Z","updated":"2022-07-24T02:01:52.133Z","comments":false,"path":"tags/index.html","permalink":"https://zhangqinc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"可变参数.md","slug":"可变参数-md","date":"2022-08-06T01:57:29.000Z","updated":"2022-08-06T01:59:14.904Z","comments":true,"path":"2022/08/06/可变参数-md/","link":"","permalink":"https://zhangqinc.github.io/2022/08/06/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0-md/","excerpt":"","text":"Java中可以提供参数数量可变的方法即变参（varargs）方法 比如：经典的printf方法。例如： 12System.out.printf(&quot;%d&quot;, n);System.out.printf(&quot;%d,%s&quot;,n,&quot;abcd&quot;); 上面两条语句调用同一个方法，但一个调用有两个参数，一个有三个参数。 或许我们可以讲printf重载，但是如果我们需要给printf传递，更多参数呢，十个，十五个？ printf方法是这样定义的： 12345public class PrintStream&#123; public PrintStream printf(String fmt, Object... args)&#123; return format(fmt, args); &#125;&#125; 这里的省略号(...)是Java代码的一部分，表示这个方法可以接收任意个该类型的 数据。 实际上，printf接受两个参数，一个是格式化字符串，一个是Object[]数组， 其实，Object数组存放着其他所有传递的参数。（若是基本数据类型，就会自动的装箱） 这就是Java中可变参数的特性，它可以让我们为方法定义一个可变长度的参数。以避免需要同时重载 传递1-10个参数的方法，甚至更多。 当我们将参数定义为可变的，在调用方法时，会将传递的多个同类型的参数存入一个数组中，也就是说，我们也可以直接将一个数组传给方法。 例如： 1System.out.printf(&quot;%d %s&quot;, new Object[] &#123;new Integer(1),abc&#125;); 下面是一个自定义的有可变参数的方法，计算若干个数中最大值： 123456789public static double max(double... values)&#123; double largest = Double.NEGATIVE_INFINITY; for (double e: values)&#123; if(v &gt; largest)&#123; largest = v; &#125; &#125; return largest;&#125; 调用上述方法： 12double m = max&#123;1, 2.4, 3.4&#125;;// 编译器会将new double[]&#123;1, 2.4, 3.4&#125;传给max方法","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"Java中super关键字的用法","slug":"super","date":"2022-07-31T10:21:06.000Z","updated":"2022-07-31T10:21:50.935Z","comments":true,"path":"2022/07/31/super/","link":"","permalink":"https://zhangqinc.github.io/2022/07/31/super/","excerpt":"","text":"super的作用super 可以用来调用父类中的方法或构造器 调用父类中的方法：若父类中的某些方法对子类不适用。即可以在子类中提供一个新的方法来覆盖&#x2F;重写（override）父类中的这个方法 eg：Manager 方法继承了 Employee 方法,现在，现在要在子类中重写父类中的getSalary方法（获取私有字段salary的值）： 1234567public class Manager extends Employee&#123; ... public double getSalary()&#123; ... &#125; ...&#125; 若： 123public double getSalary()&#123; return salary + bonus;// won&#x27;t work&#125; 这样是不行的，因为只有 Employee 方法能直接访问 Employee 类的私有字段。所以 Manager 类的getSalary 方法不能直接访问 salary 字段 如果 Manager 类要访问其父类中的私有字段，就要像其他方法一样使用公共接口， 在这里的话就是要使用Employee 类中的公共方法getSalary 现在： 1234public double getSalary()&#123; double baseSalary = getSalary();//still won&#x27;t work return baseSalary + bonus;&#125; 还是有问题的，因为它调用getSalary() 方法时是在调用Manager类中的方法（调用自身）。 super为解决上述问题，可以使用特殊的关键字super super 可以使我们调用父类中的方法。 super.getSalary(); 此语句调用的是Employee类中的getSalary方法 super 与this 不一样，因为super不是一个对象引用 super调用父类的构造器例： 1234public Manager(String name, double salary. int year, int month, int day)&#123; super(name, salary, year, month, day); bonus = 0;&#125; 这里的super语句表示调用父类中有对应参数类型的构造器 如果子类的构造器没有显式的调用父类的构造器，将自动调用父类的无参构造器，若此时父类中没有无参构造器就会报错 注： this的两个含义: 指示隐式参数的引用 调用该类的其他构造器 super的两个含义： 调用超类的方法 调用超类的构造器 内容自《Java核心技术卷I》 第五章 继承","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"单例模式","slug":"singleton","date":"2022-07-31T09:03:14.000Z","updated":"2022-07-31T09:08:39.801Z","comments":true,"path":"2022/07/31/singleton/","link":"","permalink":"https://zhangqinc.github.io/2022/07/31/singleton/","excerpt":"","text":"单例模式当我们的一个类需要要求他最多只有一个对象时，即需要确保此类只有一个实例存在时，需要使用到单例模式。 顾名思义，’’单例’’,即只有一个实例的情况。 要使用单例模式就必然要禁止外界随意创建类的对象，我们都知道，在将构造器私有化之后，外界即不可通过构造函数来创建类对应的对象。所以使用单例模式的第一步： 将构造函数私有化，以避免外界随意将该类实例化。 既然不能够从外部通过构造器来对类进行实例化，我们就需要从内部创建该类的对象并提供一个能够返回对象的方法，即第二步： 通过静态方法从内部创建该类对象并返回。（调用此方法即可获取类的对象） 单例模式在Java中通常有两种表现形式。 懒汉式 饿汉式 懒汉式第一次引用类是才进行对象实例化，即在调用的getInstance()方法块中创建类的对象再返回。 123456789101112public class Singleton&#123; private static Singleton singleton = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 优点： 节约内存 缺点： 有线程安全问题 饿汉式定义对象变量时就将其初始化，在类加载时就进行对象的实例化，当调用getInstance()方法时返回该对象。 123456789public class Singleton&#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; private static Singleton getInstance()&#123; return singleton; &#125;&#125; 优点： 线程安全，提前加载到内存 缺点： 提前加载到内存，资源占用","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"throwable","slug":"throwable","date":"2022-07-31T04:00:02.000Z","updated":"2022-07-31T04:00:47.013Z","comments":true,"path":"2022/07/31/throwable/","link":"","permalink":"https://zhangqinc.github.io/2022/07/31/throwable/","excerpt":"","text":"Java中的异常处理在Java中，如果某个方法不能够采用正常的途径完成它的任务，可以通过另外一个路径退出方法。 在这种情况下，方法并不返回任何值，而是抛出（throw）一个封装了错误信息的对象。 注意，这个方法会立刻退出，并不返回任何值。 此外，也不会从调用这个方法的代码继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器（exception handler）。 异常分类异常对象都是派生于Throwable类的 如果Java中内置的异常类不能满足要求，我们还可以创建自己的异常类。 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误，这是很严重的错误。 而Exception层次结构是代表了异常类。这是要重点关注的。 Exception又大概分为两个分支: 派生于RuntimeException的异常 其他异常。 如果程序本身没有问题，但由于像I&#x2F;O错误这种问题导致的异常属于其他异常。 如果出现RuntimeException异常，那么一定是你的问题（代码问题） Java语言规范将派生于Error类或者RuntimeException类的所有异常称为非检查型（&#96;&#96;unchecked）异常**。所有的其他异常称为**检查型（checked&#96;）异常. 异常处理：两种方案 抛出异常（throws） 捕获异常（catch） 抛出异常要在方法首部指出这个方法可能抛出一个异常，所以要修饰方法首部。 例如： 1234public int sum(int a) throws RuntimeException&#123;&#125;// 此方法抛出了一个RuntimeException异常。// 此方法运行时可能会出错而抛出一个RuntimeException包括它的子类。 捕获异常有些代码必须捕获异常，捕获异常需要做更多的规划。 如果发生了某个异常，但没有在任何地方捕获它，程序就会终止。 想要捕获一个异常，需要使用try/catch语句块。 如下： 1234567try&#123; // code&#125; catch (ExceptionType e)&#123; // handler for this type&#125; finally &#123; // 一定执行&#125; 如果try语句块中的任何代码抛出了catch子句中指定的一个异常类，则： 程序将跳过try语句块的其余代码。 程序将执行catch子句中的代码。 如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句。 finally中的语句一定执行，如回收资源，关闭流等操作 自定义异常&#x2F;&#x2F;TODO","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"抽象类与接口简介整理","slug":"抽象类与接口简介整理","date":"2022-07-25T10:29:04.000Z","updated":"2022-07-25T10:29:04.950Z","comments":true,"path":"2022/07/25/抽象类与接口简介整理/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B%E6%95%B4%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JDK环境配置","slug":"JDK环境配置","date":"2022-07-25T10:16:39.000Z","updated":"2022-07-25T10:25:27.386Z","comments":true,"path":"2022/07/25/JDK环境配置/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/JDK%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"JavaWrite once，run anywhere 主要用于web开发 jdk: Java Development Kit java开发工具 jre: java Runtime Environment java运行环境 jvm: java Virtual Machine java虚拟机 java环境变量配置JAVA_HOME 对应路径为jdk的安装目录 配置path变量 %JAVA_HOME%\\bin %%是指引用路径，即，jdk下的bin目录 %JAVA_HOMOE%\\jre\\bin 都对应的是真实的目录 测试jdk是否安装成功cmd中，java -version 查看jdk版本信息—&gt;查看成功即安装ok。 了解jdk目录 bin 放一些可执行程序，还有一些运行工具 include 因为是c编写的，在启动时需要去引入一些c的头文件 jre Java运行环境 lib Java一些类库文件 src 一些资源文件，一些源代码。。 如何手动编译运行Java代码文件 编写后在该目录打开cmd窗口 执行命令javac 文件名.java（生成了class文件） 执行命令 java 文件名 （运行了class文件） 程序运行机制 编译型 -&gt; 操作 系统 c&#x2F;c++ 解释型 -&gt; 网页，速度 各有利弊 程序运行机制 IDE 集成开发环境，用于提供程序开发环境的软件，将开发过程中需要使用的各种功能（开发、运行、打包、测试、项目管理、连接。。。）工具整合为一个统一的软件，IDE IDEA","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"面向对象程序设计简概","slug":"面向对象程序设计简概","date":"2022-07-25T10:02:15.000Z","updated":"2022-07-25T10:06:12.874Z","comments":true,"path":"2022/07/25/面向对象程序设计简概/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AE%80%E6%A6%82/","excerpt":"","text":"4.1 面向对象程序设计概述4.2.1 对象与对象变量Java中，要想使用变量，首先必须先构造对象，并指定其初始状态（初始化），然后对对象应用方法。 对象和对象变量的重要区别Date deadline; 定义了一个对象变量deadline，它可以引用Date类型的对象，但它不是一个对象，所以此时还不能在其上使用任何Date方法。 此时可以让它引用一个新构造的对象或者一个已存在的对象 deadline = new Date(); deadline = birthday; 对象变量并没有实际包含一个对象，它只是引用一个对象 相当于一个指针 Java中，任何对象变量的值都是对存储在另一个地方的某个对象的引用，new操作符的返回值也是一个引用。 构造器 Java中没有类就无法做任何事情 要想使用对象，首先必须构造对象，并指定其初始状态，然后再对对象应用方法。 Java中，要使用构造器（constructor）构造新实例。 构造器定义构造器是一种用来构造并初始化对象的特殊方法。 java用类描述时间，这样的话，如果类设计的不完善，不符合使用者的要求，其他程序员就要很容易的修改、编写自己的类，以便增强或替代系统提供的类。 构造器的结构及特性 构造器的名字应该和类名一致 要构造一个对象需要在构造器前面加new操作符 eg : new Date() 如果需要的话，也可以将这个对象传给一个方法 eg : System.out.println(new Date()); 也可以直接对刚创建的对象应用一个方法 Date类中的toString方法将返回日期的字符串描述 String s = new Date().toString(); 以上两个构造对象都仅仅使用了一次。而一般情况下，需要将构造对象使用多次，就需要将对象存在一个变量中。、 Date birthday = new Date(); 构造器与类同名 每个类可以有一个以上的构造器（类似于重载） 构造器可以有0个，1个或多个参数（任意个） 构造器没有返回值 构造器总是伴随着new操作符一起调用 4.3.5 用var声明局部变量Java 10 中，若可从变量的初始值推导出他的类型，就可以用var关键字，声明局部变量，无需指定类型 eg： Employee harry = new Employee(&quot;Harry Hacker&quot;, 50000, 1989,10,1); 只需 var harry = new Employee(&quot;Harry Hacker&quot;, 50000, 1989,10,1); 不会对数值类型使用var 如int、long、double等 var关键字只能用于方法中的局部变量，而参数和字段的类型必须声明。 4.3.6 使用null引用 一个对象变量包含一个对象的引用，或者包含一个特殊的null值用来表示没有引用任何对象。 如果对null值应用一个方法，会产生一个NullPointerException异常 且正常情况下，程序并不会捕获这些异常 4.3.7 隐式参数和显示参数1234public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100; salary += raise;&#125; raiseSalary 方法有两个参数。 第一个参数为隐式（implicit）参数，是出现在方法名前的Employee类型的对象。（有人把隐式参数称为方法调用的目标或接收者）。 第二个参数是位于方法名后面括号中的数值，即显式（explicit）参数。 显式参数显式的列在方法声明中 隐式参数没有出现在方法声明中 在每一个方法中，关键字this 指示隐式参数。即： 1234public void raiseSalary(double byPercent)&#123; double raise = this.salary * byPercent / 100; this.salary += raise;&#125; 4.3.8 封装的优点 数据字段均设为私有的 一个公共的字段访问器方法（Getter） 一个公共的字段更改器方法（Setter） 注：不要编写返回可变对象引用的访问器方法 4.3.9 基于类的访问权限 方法可以访问调用这个方法的对象的私有数据 一个方法可以访问所属类的所有对象的私有数据 4.3.10 私有方法 公共数据非常危险，所以应该将所有的数据字段都设置为私有的 使用private设置方法为私有 只要方法是私有的，类的设计者就可以确信它不会在别处使用，所以可以不用时删除 如果一个方法是公共的，就不能简单的将其删除，因为可能会有其他的代码依赖这个方法。 4.3.11 final 实例字段 在定义实例字段时候可以将其定义为final eg： 1234class Employee&#123; private final String name; ......&#125; 这样的字段必须在构造对象时初始化 即确保在每一个构造器执行之后，这个设置为final的字段的值已经被设置，且不能再更改 因为再对象构造之后，这个值不会再改变，所以没有setName方法 用途 用于类型为基本类型或者不可变类的字段（类中的所有方法都不会改变其对象，这样的类就是不可变的类).如：String类就是不可变类 4.4 静态字段和静态方法4.4.1 静态字段 如果将一个字段定义为static ，每个类只有一个这样的字段 而对于非静态的实例字段，每个对象都有自己的一个副本 eg:若需要给每一个员工赋予唯一的标识码，这里添加一个实例字段id和一个静态字段nextId； 123456class Employee&#123; private static int nextId = 1; private int id; ......&#125; 设置为static之后，所有的Employee类的实例将共享一个此字段，即，每一个Employee对象都有属于自己的实例字段id，但是它们只有一个静态字段nextId，且即使还没有Employee对象，但是静态字段nextId仍然存在。即，它属于这整个类，而不是单独属于类的某个对象。 在一些面向对象程序设计语言中，静态字段被称为类字段。静态二字只是沿用了C++的叫法，而没有实际意义。 4.4.2 静态常量 静态变量使用的比较少，但静态常量很常用 eg： 1234public class Math&#123; ... public static final double PI = 3.14159265358979;&#125; 在程序中可以用Math.PI来访问这个常量 若省略关键字static，PI就变成了Math类的一个实例字段，而成为实例字段之后就需要通过Math的一个对象来访问PI，并且每一个Math对象都有它自己的一个副本。 最好不要有公共字段，但是公共常量（final字段）却完全可以有，因为其被声明为final，所以不允许被重新赋值。 注：System类中有一个setOut方法可以将System.out 设置为不同的流，而改变了final变量的值。这里用了一个原生方法。 原生方法是一种特殊的解决方法，可以绕过 Java 语言的访问控制机制。 4.4.3 静态方法 静态方法是不在对象上执行的方法 eg: Math类的pow方法就是一个静态方法 使用此方法时并不使用任何Math对象，也就是说它没有隐式参数。即没有this参数的方法。 Employee 类的静态方法不能访问 id 实例字段，因为他不能在对象上执行操作。但是静态方法可以刚问静态字段、 eg： 123public static int getNextId()&#123; return nextId; // returns static field&#125; 可以提供类名来调用这个方法： int n = Employee.getNextId(); 若省略了关键字 static 就需要通过 Employee 类对象的引用来调用这个方法 若使用对象调用静态方法也是合法的，但是这种写法容易混淆，所以最好使用类名来调用静态方法，而不是使用对象。 使用静态方法的情况 方法不需要访问对象状态，因为他需要的所有参数都通过显式参数提供（eg：Math.pow） 方法只需要访问类的&#x3D;&#x3D;静态字段&#x3D;&#x3D;（eg：Employee.getNextId） 可以调用静态方法而不需要任何对象，eg：不需要构造Math类的任何对象就可以调用Math.pow 4.4.4 工厂方法即静态方法的另一种用途：静态工厂方法 类似于 LocalDate 和NumberFormat 的类使用静态工厂方法（factory method）来构造对象。 如工厂方法LocalDate.now和LocalDate.of 特性及优点 4.4.5 main方法 main 方法也是一个静态方法 main方法不对任何对象进行操作。 在启动程序时还没有任何对象，而静态的main方法将执行并构造程序所需要的对象 每一个类都可以有一个main方法，这是常用于对类进行单元测试的一个技巧 如，可以在 Employee 类中添加一个 main 方法，见程序4-3 程序清单4-3 StaticTest4.5 方法参数如何将参数传递给方法的一些专业术语： 安置调用（call by value）表示方法接收的是调用者提供的值 按引用调用（call by reference)表示方法接收的是调用者提供的变量地址 方法可以修改按引用传递的变量的值，但是不能修改按值传递的变量的值。 “按……调用”（call by）是一个标准的计算机科学术语，用来描述各种程序设计语言中方法参数的传递方式。 实际上还有按名调用，但是这种传递方式已经成为历史 Java 总是采用按值调用，也就是说，方法得到的是所有参数值的一个副本。 所以方法不能修改传递给它的任何参数变量的内容。 而参数类型有两种： 基本数据类型（布尔、数值） 对象引用 一个方法不可能修改基本数据类型的参数，但可以修改对象引用的参数 虽然方法通过参数得到的是一个对象引用的副本，但是原来的对象引用和此副本引用的是同一个对象 eg：利用下面这个方法将一个员工的工资增长至三倍 123public static void tripleSalary(Employee x)&#123; x.raiseSalary(200);&#125; 当调用 12harry = new Employee(...);tripleSalary(harry); 具体的执行过程为: x初始化为harry值的一个副本，这里就是一个对象引用 raiseSalary方法应用于这个对象引用。x和harry同时引用的那个Employee对象的工资提高了200% 方法结束后，参数变量x不再使用，然后对象变量harry继续引用那个工资增长至三倍的员工对象 Java语言对对象采用的并不是按引用调用的参数传递方式 很多人都认为Java采用的引用调用（甚至有些书的作者） 反例： 首先编写一个交换两个Employee对象的方法； 12345public static void swap(Employee x, Employee y)&#123; Employee temp = x; x = y; y = x;&#125; 若Java对对象采用的是按引用调用，那么这个方法可以实现调换 但是： 此方法并没有改变存储在变量中的对象引用。而是交换了两个副本。因为&#96;&#96;swap&#96;方法的参数 x 和 y 被初始化为两个对象引用的副本。 实际上对象引用时按值传递的 总结：（Java中对方法参数能做什么和不能做什么） 方法不能修改基本数据类型的参数 方法可以改变对象参数的状态 方法不能让一个对象参数引用一个新的对象 Demo：程序清单 4-4ParamTest 4.6 对象的构造构造器可以定义对象的初始状态，但是由于对象构造非常重要，所以Java 提供了多种编写构造器的机制 4.6.1 重载 多个方法有相同的名字、不同的参数，即出现了重载。 此时调用方法时编译器需要通过各个方法首部中的参数类型与特定方法调用中所使用的值类进行匹配来选出正确的方法。 此过程称为重载解析。 Java 允许重载任何方法 要完整的描述一个方法，需要指定方法名以及参数类型，这叫方法的签名 返回类型不是方法签名的一部分，所以不能有两个名字相同、参数类型也相同却有不同返回类型的方法 4.6.2 默认字段初始化 如果在构造器中额米有显式的为字段设置初值，那么就会被自动的赋为默认值：（0， null， 或false） 这也是字段和局部变量的一个重要区别 -&gt; 方法中发局部变量必须明确的初始化。但是在类中，如果没有初始化类中的字段，将会自动初始化为默认值 4.6.3 无参数的构造器 当写一个类时候没有编写构造器，就会自动提供一个无参的构造器 若设置了构造器，默认给的就无了 通过重载类的构造器方法，可以采用多种形式设置类的实例字段的初始状态 4.6.4 显式字段初始化调用构造器，每个实例字段都要设置为一个有意义的初值 可以在类定义中直接为任何字段赋值，如： 1234class Employee&#123; private String name = &quot;&quot;; ......&#125; 如果一个类的所有构造器都希望把某个特定的实例字段设置为同一个值，就很有用 而初值不一定是常量值，可以利用方法调用初始化一个字段 eg: 1234567891011class Employee&#123; private static int nextId; private int id = assignId(); ... private static int assignId()&#123; int r = nextId; nextId++; return r; &#125; ...&#125; 在 C++ 中，不能直接初始化类的实例字段。所有的字段都必须在构造器中设置。 4.6.5 参数名编写小构造器命名技巧： 在每个参数前面加上一个前缀“a”。 使用关键字 this 4.6.6 调用另一个构造器构造器调用同一个类中的另一个构造器，this(/*参数*/) 一个构造器中最多只能调用一个构造器 必须写在构造器执行体的第一行语句 使用this调用另一个重载构造器，只能在构造器中使用 4.6.7 初始化块两种初始化数据字段的方法： 在构造器中设置值 在声明中赋值 Java还有第三种机制 -&gt; 初始化块（initialization block） 在一个类的声明中，可以包含任意多个代码块。只要构造这个类的对象，这些块就会被执行。 调用构造器时，会首先运行初始化块，然后才运行构造器的主体部分 （这种机制不必需，不常见） 调用构造器的具体处理步骤 如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器，否则: 所有数据字段初始化为其默认值 按照在类声明中出现的顺序，执行所有字段初始化方法和初始化块 执行构造器主体代码 程序清单 4-5其中展示了本节许多特性： 重载构造器 用this（…）调用另一个构造器 无参数构造器 对象初始化块 静态初始化块 实例字段初始化 静态初始化块、初始化块和构造方法的理解 API java.util.Random Random() 构造一个新的随机数生成器 int nextInt(int n) 返回一个0~n-1之间的随机数 4.6.8 对象析构与 finalize 方法4.7 包Java允许使用包（package），将类组织在一个集合中，借助包可以方便的组织自己的代码，并将自己的代码与别人提供的代码，库分开管理。 4.7.1 包名 使用包的主要原因是要确保类名的唯一性 即同名类放在不同包中就不会产生冲突 以域名的逆序的形式作为包名 4.7.2 类的导入一个类可以使用所属包中的所有类， 以及其他包中的公共类（public class）。 访问另一个包中的类有两种方式： 完全限定名（fully qualified name)就是包名后面跟着类名 java.time.LocalDate tofay &#x3D; java.time.LocalDate.now(); import 语句。 可以使用 import 语句导入一个特定的类或整个包， import 语句应该位于源文件的顶部（但位于 package 语句的后面） import java.time.LocalDate; 然后就可以使用： LocalDate today &#x3D; LocalDate.now(); 只能使用“*”导入一个包，而不能使用import java.* 或import java.*.* 导入以java为前缀的所有包 若发生命名冲突就需注意导入的两个包是否有同名类 可加一个特定的 import 语句来解决: 123import java.util.*;import java.sql.*;import java.util.Date; 若两个 Date 类都需要使用，可以在类名前加上完整的包名，即使用完全限定名。 在包中定位类是编译器的工作。类文件中的字节码总是使用完整的包名引用其他类。 import 和 #include 并没有共同之处 4.7.3 静态导入","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"Core Java","slug":"Core-Java","permalink":"https://zhangqinc.github.io/tags/Core-Java/"}]},{"title":"面向对象的三大特征","slug":"面向对象的三大特征","date":"2022-07-25T09:30:25.000Z","updated":"2022-07-25T09:32:28.016Z","comments":true,"path":"2022/07/25/面向对象的三大特征/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/","excerpt":"","text":"面向对象的三大特征面向对象有三个大特征： 封装 继承 多态 面向对象的三大基本特征都是为了代码重用 即减少重复性的代码，大大降低程序员的工作量，提高代码的复用率。 封装封装就是把客观事物封装成（定义成）抽象的类，且隐藏类的属性（对其私有化，使用private修饰符修饰）和实现细节，只对外公开一些接口来实现对指定数据的修改（set）和读取（get）,以及指定功能（方法method）的使用。 将属性封装起来再提供接口来访问和设置相比提供一个简单的公共数据字段复杂，但是却明显有以下好处： 可以改变内部实现，而除了该类的方法以外，不回应i想其他方法。 setter方法可以完成错误检查，即检查传进的参数是否有问题，不符合预期。 增强了安全性并简化了编程， 比如我们可以对一个指定属性只设置Getter方法而不设置Setter方法，这样的话，一旦在构造器中设置此字段，就没有任何方法可以对它进行修改 继承继承的基本思想是: 基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。 父类抽取出了他所有子类的共性，而每个子类都有都继承了父类的特征（属性和方法），又可以增加属于自己的特征（属性和方法）。 is-a关系is-a关系是继承的一个明显特征。 假如你在某个公司工作，这个公司里的经理和普通员工的待遇存在一些差异，但是也有着很多相同的地方，比如说他们都领工资，但是经理在领完工资后还有奖金，这时就需要继承。 我们需要为经理定义一个Manager类，继承Employee类，并增加一些新的功能 上述例子中Manager和Employee之间存在着is-a关系。 Java中，使用extends关键字来表示继承，如下形式来定义继承Employee类的Manager类 123public class Manager extends Employee&#123; added methods and fields.&#125; 关键字extends关键字extends表明正在构造的新类派生于一个已存在的类。 这个已存在的类称为超类（superclass）、基类（base class）、或者父类（parent class） 新类称为子类（subclass）、派生类（derived class）或者孩子类（child class）。 尽管Employee类是一个父类，但是他并不比子类拥有更多的功能，相反，子类比父类拥有的功能更多。 通过扩展父类定义子类的时候，只需要指出子类与父类的不同之处即可，所以在设计类的时候，应该将最一般的方法放在父类中，而将更特殊的方法放在子类中。 即，需要将通用功能抽取到父类 覆盖方法（Override）父类中的有些方法对子类不一定使用，为此需要提供一个新的方法来覆盖&#x2F;重写（Override）父类中的这个方法。 只需要定义一个与父类中需要重写的方法同名的方法并加上注解@Override即可重写该方法。 super阻断继承：final类和方法不允许扩展的类被称为final类。即该类不能作为父类，不允许被继承，或者说不能派生子类。 在定义类时用final修饰符就表明这个类是final类。 类中的某个方法也可以被声明为final，这样的话，子类就不能重写该方法。（final类中的所有方法默认为final方法，当然，final类不拥有子类） 多态is-a规则指出子类的每个对象也是父类的对象。例如，每个经理都是员工，反之则不然，并不是每一名员工都是经理。 is-a规则的另一种表述是替换原则。他指出程序中出现父类的任何地方都可以使用子类对象替换。 可以将子类对象赋给父类变量 1234Employee e;e = new Employee();e = new Manager(); // 在Java中，对象变量是多态的（polymorphic）。 一个Employee类型的变量，既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象。 但是不能将父类引用赋给子类变量。 当一个父类变量存放了一个子类引用时，此变量只能够使用父类的方法，而不能使用子类的方法，因为其声明的类型是父类。即不能调用子类新增的扩展的方法和属性。 但是此时若是子类中相应的重写了父类的方法，则调用的是子类中已经重写的方法。 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件： 继承 重写（子类继承父类后对父类方法进行重新定义） 父类引用指向子类对象 强制类型转换","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"接口和抽象类","slug":"接口和抽象类","date":"2022-07-25T09:30:02.000Z","updated":"2022-07-25T09:31:44.249Z","comments":true,"path":"2022/07/25/接口和抽象类/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"Interface and abstract class为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？使用抽象类表示通用属性存在一个很严重的问题： 每个类只能扩展一个类。 Java是不支持多重继承的，但是每个类可以实现多个接口。 有些编程语言中允许一个类有多个父类（C++），我们将这个特性称为多重继承。 Java不支持多重继承，主要原因是多重继承会让语言变的非常复杂（如同C++），或者效率会降低（如同Eiffel）。 实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"autoboxing","slug":"autoboxing","date":"2022-07-24T11:38:27.000Z","updated":"2022-07-24T11:39:21.575Z","comments":true,"path":"2022/07/24/autoboxing/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/autoboxing/","excerpt":"","text":"对象包装器与自动装箱 Java是一门非常纯粹的面向对象的编程语言,其设计理念是“一切皆对象”。但8种基本数据类型却不具备对象的特性。据说Java之所以提供8种基本数据类型,主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性,但在某些时候也会受到一些制约。比如,所有的引用类型的变量都继承于Object类,都可以当做Object类型的变量使用,但基本数据类型却不可以。如果某个方法需要Object类型的参数,但实际需要传入的值却是数字的话,就需要做特殊的处理了。 这时我们需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。 eg： Integer 类对应基本类型为int。通常，这些与基本类型对应的类称为包装器（wrapper）。 包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。 同时，包装器类还是final，因此不能派生它们的子类。 假设我们想要定义一个整型数组列表。但是尖括号中的类型参数不允许是基本类型，ArrayList&lt;int&gt;是不允许的。这时我们就可以用到Integer包装器类。 1ArrayList&lt;&gt; list = new ArrayList&lt;Integer&gt;(); 这样，我们在向list中添加数据时，就应该添加Integer对象，但是，Java中有一个很有用的特性，可以很简单的向ArrayList&lt;Integer&gt;中添加int类型的元素； 让 1list.add(3); 自动的变换成 1list.add(Integer.valueOf(3)); 这种变换称为自动装箱(autoboxing) “装箱”（boxing）这个词来源于C# 相反的，当将一个Integer对象赋给一个int值时，将会自动的拆箱。 也就是说，编译器将以下语句： 1int n = list.get(i) 转换成： 1int n = list.get(i).intValue(); 自动的装箱与拆箱也适用于算术表达式。例如自增运算符： 12Integer n = 3;n++; // 编译器自动插入一条对象拆箱的指令，运算完成后再装箱。 大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性。 ​ &#x3D;&#x3D; 运算符运用于对象时检测的是对象是否有相同的内存位置。 不同包装类不能直接进行比较不能用&#x3D;&#x3D;进行直接比较。 不能使用compareTo方法进行比较,虽然它们都有compareTo方法,但该方法只能对相同类型进行比较 所以 1234Integer a = 1000;Integer b = 1000;if(a == b)... //此语句通常会失败； 自动装箱规范要求 boolean、byte、char &lt;= 127 介于-128和127之间的short和int被包装到固定的对象中。 即如果在此范围内的short&#x2F;int值的&#x3D;&#x3D;运算比较结果一定成功。 自动装箱注意的点： 包装器类引用可以为null，若没有值，则可能会NullPointerException 12Integer n = null;System.out.println(2*n); // throws NullPointerException 若在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升转换为double，再装箱为Double. 1234Integer n = 1;Double x = 2.0;System.out.println(true? n : x);// prints 1.0 装箱和拆箱是编译器要做的工作，而不是虚拟机。 编译器在生成类的字节码文件时就会插入必要的方法调用（自动的拆箱和装箱），虚拟机只是执行这些代码。 使用数值包装器通常还有一个原因：可以将某些基本方法放在包装器中，会很方便—&gt; API文档。 123// 将一个数字字符串转换成数值int x = Integer.parseInt(s);// 这里，parseInt与Integer对象没关系，它是一个static静态方法(工具方法)，只是Integer类是一个放它的好地方。 其它数值类也实现了一些有用的方法。 Warning: 有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。 Java方法的参数总是按值传递，所以不可能编写一个能够增加整型参数值的Java方法。 因为Integer对象是不可变的，包含在包装器中的内容不会改变。不能使用这些包装器类创建会修改数值参数的方法。 如果确实向别写一个修改数值参数值的方法，可以使用org.omg.CORBA包中定义的某个持有者（holder）类型，包括IntHolder、BooleanHolder等。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java中常用Class","slug":"Class","date":"2022-07-24T10:44:13.000Z","updated":"2022-07-25T10:07:32.315Z","comments":true,"path":"2022/07/24/Class/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/Class/","excerpt":"","text":"Java中部分常用内置类StringJava中字符串属于对象，Java内置的String类来创建和操作字符串。 拼接字符串最常用的是+，而很少用String的concat方法。 int compareTo(String anotherString)按照字符串顺序，比较两个字符串的不同。 boolean contains(CharSequence cs)当字符串包含指定的char值序列时返回true。 boolean equals(Object anObject)与指定对象比较，与String对象比较时比较字符串内容是否相同。 int indexOf(int ch)返回字符串第一次出现指定字符的序列。 int lastIndexOf(int ch)从后往前遍历返回字符串第一次出现指定字符的序列。 int length()返回该字符串的长度。 char[] toCharArray()将此字符串转换为一个char类型的数组返回。 更多详细内容请见：https://docs.oracle.com/javase/9/docs/api/java/lang/String.html# Random此类用于生成随机数。 int nextInt()返回一个int型的伪随机数。 int nextInt(int bound)返回一个0到指定范围（不包括）内的随机int值。 float nextFloat()double nextDouble()long nextLong() 更多详情请见：https://docs.oracle.com/javase/9/docs/api/java/util/Random.html MathMath 类包含执行基本数值运算的方法，例如初等指数、对数、平方根和三角函数。 Math类中的方法都为 static ，所以可直接调用，而不用创建对象。 static int abs(int a)返回int类型值的绝对值 static double abs(int a)… static int max(int a, int b)返回两个int值中更大的一个 … static int min(int a, int b)返回两个int值中更大的一个 … static double pow(double a, double b)返回第一个参数的第二个参数次幂的值。 … 更多详细方法详见：https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html ScannerScanner是一个简单的文本扫描器。 简单的使用方法如下： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); int nextInt()将输入的下一个标记扫描为 int。 更多细节方法内容见:https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"Array","slug":"Array","date":"2022-07-23T07:49:06.000Z","updated":"2022-07-25T10:07:17.815Z","comments":true,"path":"2022/07/23/Array/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/Array/","excerpt":"","text":"数组​ 数组存储相同类型值的序列。 ​ 数组是一种数据结构，用来存储同一类型值的集合。 声明数组通过一个整型下标（index）或者称为索引，可以访问数组中的每一个值。 12例如： 如果 a 是一个整型数组（int[]）, a[i] 即为数组中下标为i的整数。 声明数组时需要指出数组类型(数据元素类型后紧跟 [] )以及数组名。 1int[] a; 上述语句只声明了一个变量a，并没有将它真正初始化为一个数组，应该用new操作符创建数组： 1234int[] a = new int[100];// 此语句声明并初始化了一个可以存储100个int型数据元素的数组。//即声明格式为:// 数据类型[] 变量名 = new 数据类型[数组长度] 定义一个数组变量有两种方法： int[] a; int a[]; 这里建议用第一种，因为它更加清晰更容易理解，它将变量名和数据类型分开 数组长度不要求是常量，即也可为变量。 一旦创建了数组，它的长度就固定了，不能再做改变， 数组元素的值可以任意改变 程序运行中需要经常扩展数组的大小，这时我们可以声明一个新的更大的数组，再将需要扩展的数组的元素拷贝到新的数组。 但是当需要扩展数组大小时我们应该使用另一种数据结构——数组列表（array list） Java中，提供了叶子红创建数组对象并为其提供初始值的简写形式： 123int[] a = &#123;1, 2, 3, 4&#125;// 此语法不需要new，甚至不需要指定数组长度。// 最后一个值后面允许有逗号。 注：数组允许重新初始化。 访问数组元素int[] a = new int[100] 此数组的下标是 0-99，而不是 1-100。 创建一个数组时： 所有元素都会被初始化为0 boolean 数组的元素会被初始化为 false 对象数组的元素会被初始化为null，表示这些元素还未存放任何对象。 注：如果试图访问数组范围以外的数据eg: a[100],即越界，就会引发“array index out of bounds”异常。 要获取数组长度可以使用array.length。 for each 循环for each是Java中一种功能很强的循环结构，额可以用来依次处理数组或者其他元素集合中的每一个值，而不用去考虑下标值。 增强for循环的语句格式: 1for (variable : collection) statement for each 循环语句会遍历数组中的每一个元素 当然，使用传统的for循环也能实现相同的效果 但是for each的代码更加简洁，不易出错， 你可以不必担心下标的起始问题。 当然，for each只适用于遍历数组的所有元素的情况。很多情况下仍要使用传统的for循环。 利用Arrays类中的toString方法可以更加简单快速的打印数组中的所有元素。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-07-23T05:24:15.056Z","updated":"2022-07-23T05:24:15.056Z","comments":true,"path":"2022/07/23/hello-world/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Core Java","slug":"Core-Java","permalink":"https://zhangqinc.github.io/tags/Core-Java/"}]}