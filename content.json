{"meta":{"title":"zhang's blog","subtitle":"blog","description":"My Blog","author":"Zhang","url":"https://zhangqinc.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"about/index.html","permalink":"https://zhangqinc.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"categories/index.html","permalink":"https://zhangqinc.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"books/index.html","permalink":"https://zhangqinc.github.io/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-07-24T02:01:52.130Z","updated":"2022-07-24T02:01:52.130Z","comments":false,"path":"/404.html","permalink":"https://zhangqinc.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":true,"path":"links/index.html","permalink":"https://zhangqinc.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-24T02:01:52.133Z","updated":"2022-07-24T02:01:52.133Z","comments":false,"path":"tags/index.html","permalink":"https://zhangqinc.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"repository/index.html","permalink":"https://zhangqinc.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"autoboxing","slug":"autoboxing","date":"2022-07-24T11:38:27.000Z","updated":"2022-07-24T11:39:21.575Z","comments":true,"path":"2022/07/24/autoboxing/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/autoboxing/","excerpt":"","text":"对象包装器与自动装箱 Java是一门非常纯粹的面向对象的编程语言,其设计理念是“一切皆对象”。但8种基本数据类型却不具备对象的特性。据说Java之所以提供8种基本数据类型,主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性,但在某些时候也会受到一些制约。比如,所有的引用类型的变量都继承于Object类,都可以当做Object类型的变量使用,但基本数据类型却不可以。如果某个方法需要Object类型的参数,但实际需要传入的值却是数字的话,就需要做特殊的处理了。 这时我们需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。 eg： Integer 类对应基本类型为int。通常，这些与基本类型对应的类称为包装器（wrapper）。 包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。 同时，包装器类还是final，因此不能派生它们的子类。 假设我们想要定义一个整型数组列表。但是尖括号中的类型参数不允许是基本类型，ArrayList&lt;int&gt;是不允许的。这时我们就可以用到Integer包装器类。 1ArrayList&lt;&gt; list = new ArrayList&lt;Integer&gt;(); 这样，我们在向list中添加数据时，就应该添加Integer对象，但是，Java中有一个很有用的特性，可以很简单的向ArrayList&lt;Integer&gt;中添加int类型的元素； 让 1list.add(3); 自动的变换成 1list.add(Integer.valueOf(3)); 这种变换称为自动装箱(autoboxing) “装箱”（boxing）这个词来源于C# 相反的，当将一个Integer对象赋给一个int值时，将会自动的拆箱。 也就是说，编译器将以下语句： 1int n = list.get(i) 转换成： 1int n = list.get(i).intValue(); 自动的装箱与拆箱也适用于算术表达式。例如自增运算符： 12Integer n = 3;n++; // 编译器自动插入一条对象拆箱的指令，运算完成后再装箱。 大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性。 ​ &#x3D;&#x3D; 运算符运用于对象时检测的是对象是否有相同的内存位置。 不同包装类不能直接进行比较不能用&#x3D;&#x3D;进行直接比较。 不能使用compareTo方法进行比较,虽然它们都有compareTo方法,但该方法只能对相同类型进行比较 所以 1234Integer a = 1000;Integer b = 1000;if(a == b)... //此语句通常会失败； 自动装箱规范要求 boolean、byte、char &lt;= 127 介于-128和127之间的short和int被包装到固定的对象中。 即如果在此范围内的short&#x2F;int值的&#x3D;&#x3D;运算比较结果一定成功。 自动装箱注意的点： 包装器类引用可以为null，若没有值，则可能会NullPointerException 12Integer n = null;System.out.println(2*n); // throws NullPointerException 若在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升转换为double，再装箱为Double. 1234Integer n = 1;Double x = 2.0;System.out.println(true? n : x);// prints 1.0 装箱和拆箱是编译器要做的工作，而不是虚拟机。 编译器在生成类的字节码文件时就会插入必要的方法调用（自动的拆箱和装箱），虚拟机只是执行这些代码。 使用数值包装器通常还有一个原因：可以将某些基本方法放在包装器中，会很方便—&gt; API文档。 123// 将一个数字字符串转换成数值int x = Integer.parseInt(s);// 这里，parseInt与Integer对象没关系，它是一个static静态方法(工具方法)，只是Integer类是一个放它的好地方。 其它数值类也实现了一些有用的方法。 Warning: 有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。 Java方法的参数总是按值传递，所以不可能编写一个能够增加整型参数值的Java方法。 因为Integer对象是不可变的，包含在包装器中的内容不会改变。不能使用这些包装器类创建会修改数值参数的方法。 如果确实向别写一个修改数值参数值的方法，可以使用org.omg.CORBA包中定义的某个持有者（holder）类型，包括IntHolder、BooleanHolder等。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java中常用Class","slug":"Class","date":"2022-07-24T10:44:13.000Z","updated":"2022-07-24T10:46:52.200Z","comments":true,"path":"2022/07/24/Class/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/Class/","excerpt":"","text":"Java中部分常用内置类StringJava中字符串属于对象，Java内置的String类来创建和操作字符串。 拼接字符串最常用的是+，而很少用String的concat方法。 int compareTo(String anotherString)按照字符串顺序，比较两个字符串的不同。 boolean contains(CharSequence cs)当字符串包含指定的char值序列时返回true。 boolean equals(Object anObject)与指定对象比较，与String对象比较时比较字符串内容是否相同。 int indexOf(int ch)返回字符串第一次出现指定字符的序列。 int lastIndexOf(int ch)从后往前遍历返回字符串第一次出现指定字符的序列。 int length()返回该字符串的长度。 char[] toCharArray()将此字符串转换为一个char类型的数组返回。 更多详细内容请见：https://docs.oracle.com/javase/9/docs/api/java/lang/String.html# Random此类用于生成随机数。 int nextInt()返回一个int型的伪随机数。 int nextInt(int bound)返回一个0到指定范围（不包括）内的随机int值。 float nextFloat()double nextDouble()long nextLong() 更多详情请见：https://docs.oracle.com/javase/9/docs/api/java/util/Random.html MathMath 类包含执行基本数值运算的方法，例如初等指数、对数、平方根和三角函数。 Math类中的方法都为 static ，所以可直接调用，而不用创建对象。 static int abs(int a)返回int类型值的绝对值 static double abs(int a)… static int max(int a, int b)返回两个int值中更大的一个 … static int min(int a, int b)返回两个int值中更大的一个 … static double pow(double a, double b)返回第一个参数的第二个参数次幂的值。 … 更多详细方法详见：https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html ScannerScanner是一个简单的文本扫描器。 简单的使用方法如下： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); int nextInt()将输入的下一个标记扫描为 int。 更多细节方法内容见:https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]},{"title":"Array","slug":"Array","date":"2022-07-23T07:49:06.000Z","updated":"2022-07-24T10:47:22.379Z","comments":true,"path":"2022/07/23/Array/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/Array/","excerpt":"","text":"数组​ 数组存储相同类型值的序列。 ​ 数组是一种数据结构，用来存储同一类型值的集合。 声明数组通过一个整型下标（index）或者称为索引，可以访问数组中的每一个值。 12例如： 如果 a 是一个整型数组（int[]）, a[i] 即为数组中下标为i的整数。 声明数组时需要指出数组类型(数据元素类型后紧跟 [] )以及数组名。 1int[] a; 上述语句只声明了一个变量a，并没有将它真正初始化为一个数组，应该用new操作符创建数组： 1234int[] a = new int[100];// 此语句声明并初始化了一个可以存储100个int型数据元素的数组。//即声明格式为:// 数据类型[] 变量名 = new 数据类型[数组长度] 定义一个数组变量有两种方法： int[] a; int a[]; 这里建议用第一种，因为它更加清晰更容易理解，它将变量名和数据类型分开 数组长度不要求是常量，即也可为变量。 一旦创建了数组，它的长度就固定了，不能再做改变， 数组元素的值可以任意改变 程序运行中需要经常扩展数组的大小，这时我们可以声明一个新的更大的数组，再将需要扩展的数组的元素拷贝到新的数组。 但是当需要扩展数组大小时我们应该使用另一种数据结构——数组列表（array list） Java中，提供了叶子红创建数组对象并为其提供初始值的简写形式： 123int[] a = &#123;1, 2, 3, 4&#125;// 此语法不需要new，甚至不需要指定数组长度。// 最后一个值后面允许有逗号。 注：数组允许重新初始化。 访问数组元素int[] a = new int[100] 此数组的下标是 0-99，而不是 1-100。 创建一个数组时： 所有元素都会被初始化为0 boolean 数组的元素会被初始化为 false 对象数组的元素会被初始化为null，表示这些元素还未存放任何对象。 注：如果试图访问数组范围以外的数据eg: a[100],即越界，就会引发“array index out of bounds”异常。 要获取数组长度可以使用array.length。 for each 循环for each是Java中一种功能很强的循环结构，额可以用来依次处理数组或者其他元素集合中的每一个值，而不用去考虑下标值。 增强for循环的语句格式: 1for (variable : collection) statement for each 循环语句会遍历数组中的每一个元素 当然，使用传统的for循环也能实现相同的效果 但是for each的代码更加简洁，不易出错， 你可以不必担心下标的起始问题。 当然，for each只适用于遍历数组的所有元素的情况。很多情况下仍要使用传统的for循环。 利用Arrays类中的toString方法可以更加简单快速的打印数组中的所有元素。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-23T05:24:15.056Z","updated":"2022-07-23T05:24:15.056Z","comments":true,"path":"2022/07/23/hello-world/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]}