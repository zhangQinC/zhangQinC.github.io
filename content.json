{"meta":{"title":"zhang's blog","subtitle":"blog","description":"My Blog","author":"Zhang","url":"https://zhangqinc.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"about/index.html","permalink":"https://zhangqinc.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2022-07-24T02:01:52.130Z","updated":"2022-07-24T02:01:52.130Z","comments":false,"path":"/404.html","permalink":"https://zhangqinc.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"categories/index.html","permalink":"https://zhangqinc.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-07-24T02:01:52.131Z","updated":"2022-07-24T02:01:52.131Z","comments":false,"path":"books/index.html","permalink":"https://zhangqinc.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":true,"path":"links/index.html","permalink":"https://zhangqinc.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-07-24T02:01:52.133Z","updated":"2022-07-24T02:01:52.133Z","comments":false,"path":"tags/index.html","permalink":"https://zhangqinc.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-07-24T02:01:52.132Z","updated":"2022-07-24T02:01:52.132Z","comments":false,"path":"repository/index.html","permalink":"https://zhangqinc.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象的三大特征","slug":"面向对象的三大特征","date":"2022-07-25T09:30:25.000Z","updated":"2022-07-25T09:32:28.016Z","comments":true,"path":"2022/07/25/面向对象的三大特征/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/","excerpt":"","text":"面向对象的三大特征面向对象有三个大特征： 封装 继承 多态 面向对象的三大基本特征都是为了代码重用 即减少重复性的代码，大大降低程序员的工作量，提高代码的复用率。 封装封装就是把客观事物封装成（定义成）抽象的类，且隐藏类的属性（对其私有化，使用private修饰符修饰）和实现细节，只对外公开一些接口来实现对指定数据的修改（set）和读取（get）,以及指定功能（方法method）的使用。 将属性封装起来再提供接口来访问和设置相比提供一个简单的公共数据字段复杂，但是却明显有以下好处： 可以改变内部实现，而除了该类的方法以外，不回应i想其他方法。 setter方法可以完成错误检查，即检查传进的参数是否有问题，不符合预期。 增强了安全性并简化了编程， 比如我们可以对一个指定属性只设置Getter方法而不设置Setter方法，这样的话，一旦在构造器中设置此字段，就没有任何方法可以对它进行修改 继承继承的基本思想是: 基于已有的类创建新的类。继承已存在的类就是复用（继承）这些类的方法，而且可以增加一些新的方法和字段，使新类能够适应新的情况。 父类抽取出了他所有子类的共性，而每个子类都有都继承了父类的特征（属性和方法），又可以增加属于自己的特征（属性和方法）。 is-a关系is-a关系是继承的一个明显特征。 假如你在某个公司工作，这个公司里的经理和普通员工的待遇存在一些差异，但是也有着很多相同的地方，比如说他们都领工资，但是经理在领完工资后还有奖金，这时就需要继承。 我们需要为经理定义一个Manager类，继承Employee类，并增加一些新的功能 上述例子中Manager和Employee之间存在着is-a关系。 Java中，使用extends关键字来表示继承，如下形式来定义继承Employee类的Manager类 123public class Manager extends Employee&#123; added methods and fields.&#125; 关键字extends关键字extends表明正在构造的新类派生于一个已存在的类。 这个已存在的类称为超类（superclass）、基类（base class）、或者父类（parent class） 新类称为子类（subclass）、派生类（derived class）或者孩子类（child class）。 尽管Employee类是一个父类，但是他并不比子类拥有更多的功能，相反，子类比父类拥有的功能更多。 通过扩展父类定义子类的时候，只需要指出子类与父类的不同之处即可，所以在设计类的时候，应该将最一般的方法放在父类中，而将更特殊的方法放在子类中。 即，需要将通用功能抽取到父类 覆盖方法（Override）父类中的有些方法对子类不一定使用，为此需要提供一个新的方法来覆盖&#x2F;重写（Override）父类中的这个方法。 只需要定义一个与父类中需要重写的方法同名的方法并加上注解@Override即可重写该方法。 super阻断继承：final类和方法不允许扩展的类被称为final类。即该类不能作为父类，不允许被继承，或者说不能派生子类。 在定义类时用final修饰符就表明这个类是final类。 类中的某个方法也可以被声明为final，这样的话，子类就不能重写该方法。（final类中的所有方法默认为final方法，当然，final类不拥有子类） 多态is-a规则指出子类的每个对象也是父类的对象。例如，每个经理都是员工，反之则不然，并不是每一名员工都是经理。 is-a规则的另一种表述是替换原则。他指出程序中出现父类的任何地方都可以使用子类对象替换。 可以将子类对象赋给父类变量 1234Employee e;e = new Employee();e = new Manager(); // 在Java中，对象变量是多态的（polymorphic）。 一个Employee类型的变量，既可以引用一个Employee类型的对象，也可以引用Employee类的任何一个子类的对象。 但是不能将父类引用赋给子类变量。 当一个父类变量存放了一个子类引用时，此变量只能够使用父类的方法，而不能使用子类的方法，因为其声明的类型是父类。即不能调用子类新增的扩展的方法和属性。 但是此时若是子类中相应的重写了父类的方法，则调用的是子类中已经重写的方法。 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件： 继承 重写（子类继承父类后对父类方法进行重新定义） 父类引用指向子类对象 强制类型转换","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[]},{"title":"接口和抽象类","slug":"接口和抽象类","date":"2022-07-25T09:30:02.000Z","updated":"2022-07-25T09:31:44.249Z","comments":true,"path":"2022/07/25/接口和抽象类/","link":"","permalink":"https://zhangqinc.github.io/2022/07/25/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"Interface and abstract class为什么Java中要引入接口的概念呢？为什么不直接设计成抽象类中全是抽象方法呢？使用抽象类表示通用属性存在一个很严重的问题： 每个类只能扩展一个类。 Java是不支持多重继承的，但是每个类可以实现多个接口。 有些编程语言中允许一个类有多个父类（C++），我们将这个特性称为多重继承。 Java不支持多重继承，主要原因是多重继承会让语言变的非常复杂（如同C++），或者效率会降低（如同Eiffel）。 实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"autoboxing","slug":"autoboxing","date":"2022-07-24T11:38:27.000Z","updated":"2022-07-24T11:39:21.575Z","comments":true,"path":"2022/07/24/autoboxing/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/autoboxing/","excerpt":"","text":"对象包装器与自动装箱 Java是一门非常纯粹的面向对象的编程语言,其设计理念是“一切皆对象”。但8种基本数据类型却不具备对象的特性。据说Java之所以提供8种基本数据类型,主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性,但在某些时候也会受到一些制约。比如,所有的引用类型的变量都继承于Object类,都可以当做Object类型的变量使用,但基本数据类型却不可以。如果某个方法需要Object类型的参数,但实际需要传入的值却是数字的话,就需要做特殊的处理了。 这时我们需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。 eg： Integer 类对应基本类型为int。通常，这些与基本类型对应的类称为包装器（wrapper）。 包装器是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。 同时，包装器类还是final，因此不能派生它们的子类。 假设我们想要定义一个整型数组列表。但是尖括号中的类型参数不允许是基本类型，ArrayList&lt;int&gt;是不允许的。这时我们就可以用到Integer包装器类。 1ArrayList&lt;&gt; list = new ArrayList&lt;Integer&gt;(); 这样，我们在向list中添加数据时，就应该添加Integer对象，但是，Java中有一个很有用的特性，可以很简单的向ArrayList&lt;Integer&gt;中添加int类型的元素； 让 1list.add(3); 自动的变换成 1list.add(Integer.valueOf(3)); 这种变换称为自动装箱(autoboxing) “装箱”（boxing）这个词来源于C# 相反的，当将一个Integer对象赋给一个int值时，将会自动的拆箱。 也就是说，编译器将以下语句： 1int n = list.get(i) 转换成： 1int n = list.get(i).intValue(); 自动的装箱与拆箱也适用于算术表达式。例如自增运算符： 12Integer n = 3;n++; // 编译器自动插入一条对象拆箱的指令，运算完成后再装箱。 大多数情况下容易有一种假象，认为基本类型与它们的对象包装器是一样的。但它们有一点有很大不同：同一性。 ​ &#x3D;&#x3D; 运算符运用于对象时检测的是对象是否有相同的内存位置。 不同包装类不能直接进行比较不能用&#x3D;&#x3D;进行直接比较。 不能使用compareTo方法进行比较,虽然它们都有compareTo方法,但该方法只能对相同类型进行比较 所以 1234Integer a = 1000;Integer b = 1000;if(a == b)... //此语句通常会失败； 自动装箱规范要求 boolean、byte、char &lt;= 127 介于-128和127之间的short和int被包装到固定的对象中。 即如果在此范围内的short&#x2F;int值的&#x3D;&#x3D;运算比较结果一定成功。 自动装箱注意的点： 包装器类引用可以为null，若没有值，则可能会NullPointerException 12Integer n = null;System.out.println(2*n); // throws NullPointerException 若在一个条件表达式中混合使用Integer和Double类型，Integer值就会拆箱，提升转换为double，再装箱为Double. 1234Integer n = 1;Double x = 2.0;System.out.println(true? n : x);// prints 1.0 装箱和拆箱是编译器要做的工作，而不是虚拟机。 编译器在生成类的字节码文件时就会插入必要的方法调用（自动的拆箱和装箱），虚拟机只是执行这些代码。 使用数值包装器通常还有一个原因：可以将某些基本方法放在包装器中，会很方便—&gt; API文档。 123// 将一个数字字符串转换成数值int x = Integer.parseInt(s);// 这里，parseInt与Integer对象没关系，它是一个static静态方法(工具方法)，只是Integer类是一个放它的好地方。 其它数值类也实现了一些有用的方法。 Warning: 有些人认为包装器类可以用来实现修改数值参数的方法，然而这是错误的。 Java方法的参数总是按值传递，所以不可能编写一个能够增加整型参数值的Java方法。 因为Integer对象是不可变的，包含在包装器中的内容不会改变。不能使用这些包装器类创建会修改数值参数的方法。 如果确实向别写一个修改数值参数值的方法，可以使用org.omg.CORBA包中定义的某个持有者（holder）类型，包括IntHolder、BooleanHolder等。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Java中常用Class","slug":"Class","date":"2022-07-24T10:44:13.000Z","updated":"2022-07-24T10:46:52.200Z","comments":true,"path":"2022/07/24/Class/","link":"","permalink":"https://zhangqinc.github.io/2022/07/24/Class/","excerpt":"","text":"Java中部分常用内置类StringJava中字符串属于对象，Java内置的String类来创建和操作字符串。 拼接字符串最常用的是+，而很少用String的concat方法。 int compareTo(String anotherString)按照字符串顺序，比较两个字符串的不同。 boolean contains(CharSequence cs)当字符串包含指定的char值序列时返回true。 boolean equals(Object anObject)与指定对象比较，与String对象比较时比较字符串内容是否相同。 int indexOf(int ch)返回字符串第一次出现指定字符的序列。 int lastIndexOf(int ch)从后往前遍历返回字符串第一次出现指定字符的序列。 int length()返回该字符串的长度。 char[] toCharArray()将此字符串转换为一个char类型的数组返回。 更多详细内容请见：https://docs.oracle.com/javase/9/docs/api/java/lang/String.html# Random此类用于生成随机数。 int nextInt()返回一个int型的伪随机数。 int nextInt(int bound)返回一个0到指定范围（不包括）内的随机int值。 float nextFloat()double nextDouble()long nextLong() 更多详情请见：https://docs.oracle.com/javase/9/docs/api/java/util/Random.html MathMath 类包含执行基本数值运算的方法，例如初等指数、对数、平方根和三角函数。 Math类中的方法都为 static ，所以可直接调用，而不用创建对象。 static int abs(int a)返回int类型值的绝对值 static double abs(int a)… static int max(int a, int b)返回两个int值中更大的一个 … static int min(int a, int b)返回两个int值中更大的一个 … static double pow(double a, double b)返回第一个参数的第二个参数次幂的值。 … 更多详细方法详见：https://docs.oracle.com/javase/9/docs/api/java/lang/Math.html ScannerScanner是一个简单的文本扫描器。 简单的使用方法如下： 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); int nextInt()将输入的下一个标记扫描为 int。 更多细节方法内容见:https://docs.oracle.com/javase/9/docs/api/java/util/Scanner.html","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]},{"title":"Array","slug":"Array","date":"2022-07-23T07:49:06.000Z","updated":"2022-07-24T10:47:22.379Z","comments":true,"path":"2022/07/23/Array/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/Array/","excerpt":"","text":"数组​ 数组存储相同类型值的序列。 ​ 数组是一种数据结构，用来存储同一类型值的集合。 声明数组通过一个整型下标（index）或者称为索引，可以访问数组中的每一个值。 12例如： 如果 a 是一个整型数组（int[]）, a[i] 即为数组中下标为i的整数。 声明数组时需要指出数组类型(数据元素类型后紧跟 [] )以及数组名。 1int[] a; 上述语句只声明了一个变量a，并没有将它真正初始化为一个数组，应该用new操作符创建数组： 1234int[] a = new int[100];// 此语句声明并初始化了一个可以存储100个int型数据元素的数组。//即声明格式为:// 数据类型[] 变量名 = new 数据类型[数组长度] 定义一个数组变量有两种方法： int[] a; int a[]; 这里建议用第一种，因为它更加清晰更容易理解，它将变量名和数据类型分开 数组长度不要求是常量，即也可为变量。 一旦创建了数组，它的长度就固定了，不能再做改变， 数组元素的值可以任意改变 程序运行中需要经常扩展数组的大小，这时我们可以声明一个新的更大的数组，再将需要扩展的数组的元素拷贝到新的数组。 但是当需要扩展数组大小时我们应该使用另一种数据结构——数组列表（array list） Java中，提供了叶子红创建数组对象并为其提供初始值的简写形式： 123int[] a = &#123;1, 2, 3, 4&#125;// 此语法不需要new，甚至不需要指定数组长度。// 最后一个值后面允许有逗号。 注：数组允许重新初始化。 访问数组元素int[] a = new int[100] 此数组的下标是 0-99，而不是 1-100。 创建一个数组时： 所有元素都会被初始化为0 boolean 数组的元素会被初始化为 false 对象数组的元素会被初始化为null，表示这些元素还未存放任何对象。 注：如果试图访问数组范围以外的数据eg: a[100],即越界，就会引发“array index out of bounds”异常。 要获取数组长度可以使用array.length。 for each 循环for each是Java中一种功能很强的循环结构，额可以用来依次处理数组或者其他元素集合中的每一个值，而不用去考虑下标值。 增强for循环的语句格式: 1for (variable : collection) statement for each 循环语句会遍历数组中的每一个元素 当然，使用传统的for循环也能实现相同的效果 但是for each的代码更加简洁，不易出错， 你可以不必担心下标的起始问题。 当然，for each只适用于遍历数组的所有元素的情况。很多情况下仍要使用传统的for循环。 利用Arrays类中的toString方法可以更加简单快速的打印数组中的所有元素。","categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-23T05:24:15.056Z","updated":"2022-07-23T05:24:15.056Z","comments":true,"path":"2022/07/23/hello-world/","link":"","permalink":"https://zhangqinc.github.io/2022/07/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/categories/Java-SE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://zhangqinc.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Java SE","slug":"Java-SE","permalink":"https://zhangqinc.github.io/tags/Java-SE/"}]}